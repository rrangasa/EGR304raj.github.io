{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"RG Ragul Raj's Datasheet as part of  EGR 304 for  Team 101 <p>Submission: September, 03, 2025 </p><p></p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>This datasheet documents a user interface subsystem for an embedded systems project. The subsystem consists of push buttons, LEDs, and a light-resistive sensor controlled by a Microchip PIC18F57Q43 microcontroller. This reference includes the design, component selection, schematic, and power budget.</p>"},{"location":"#project-summary","title":"Project Summary","text":"<p>This subsystem provides user interaction for a larger embedded system project. It includes:</p> <ul> <li>Inputs: One push button and one light-resistive sensor</li> <li>Outputs: One LED (green) for visual feedback</li> <li>Controller: Microchip PIC18F57Q43 Curiosity Nano</li> <li>Power: 5V regulated supply from an LM7805T voltage regulator</li> </ul> <p>The subsystem connects to other project modules through three 8-pin connectors. Components were selected for reliability and ease of assembly.</p> <p>This is an individual contribution to Team 101's EGR 304 project. For the complete system overview, see the team report.</p>"},{"location":"#my-contribution","title":"My Contribution","text":"<p>This datasheet documents my individual contribution to the Team 101 embedded systems project. As part of a collaborative effort, I was responsible for designing and documenting this complete user interface subsystem/Hub.</p> <p>To explore the specific details of each design phase, navigate to the following sections: - Block Diagram: Visual representation of subsystem architecture - Component Selection: Detailed analysis of selected components - BOM: Complete bill of materials with pricing and sourcing - Schematic: Electrical circuit design - PCB: Printed circuit board design and layout - Power Budget: Power consumption analysis - Microcontroller Code: Firmware implementation and source code - Hardware V2.0: Future improvements and enhancements - Resources: KiCad and MPLAB X project files</p>"},{"location":"01-Block-Diagram/Block-Diagram/","title":"Individal Block Diagram","text":"","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#overview","title":"Overview","text":"<p>The subsystem provides user input and output feedback through one button, one LED, one potentiometer, and a light-dependent resistor (LDR). The button acts as a digital input, the LED serves as a visual indicator.</p> <p>All components operate on a regulated 5V, 1.5A supply from an LM7805CT voltage regulator (Texas Instruments #LM7805CT/NOPB). The central controller is the Microchip PIC18F57Q43 Curiosity Nano, which manages logic, inputs, and outputs. The potentiometer connects to RA3 as an analog input (0-5V), the LDR signal is amplified through an MCP6004 operational amplifier (Microchip Technology #MCP6004-I/P) and connects to RA2 as an analog input (0-5V), the green LED connects to RD4 as a digital output (5V), and the button connects to RB4 as a digital input.</p> <p>The subsystem interfaces with external modules through three 8-pin connectors. Connector 1 provides digital output (RC7) to a speaker module. Connector 2 interfaces with a motor module, receiving digital input (RD6) and providing digital output (RD7). Connector 3 receives PWM input (RC0) from a humidity sensor module. Each connector includes ground connections for proper signal referencing.</p>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#workings","title":"Workings","text":"<p>Our system follows a hub-and-spoke architecture: the hub first checks whether the ambient sunlight level is appropriate for watering using a light-resistive sensor. When the brightness conditions are suitable, the hub requests the current soil-moisture reading from the sensor subsystem. It then analyzes this data and determines whether watering is required. Based on this decision, the hub sends signals to the motor/valve (sprinkler) subsystem and the speaker to initiate watering, or remains idle if no action is needed.</p>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#block-diagram-elements-and-product-requirements","title":"Block Diagram Elements and Product Requirements","text":"<p>The following elements of the block diagram contribute to meeting the team's product requirements:</p> <ul> <li> <p>Microchip PIC18F57Q43 Curiosity Nano (Central Hub): Central hub.</p> </li> <li> <p>LDR with MCP6004 Operational Amplifier (RA2): Detects ambient light conditions to avoid inappropriate watering.</p> </li> <li> <p>Potentiometer (RA3): Provides simple analog input for testing. May be used to manually set desired moisture by the user in the future.</p> </li> <li> <p>Push Button (RB4): Provides simple digital input for testing. May be used for user insteraction in the future.</p> </li> <li> <p>Green LED (RD4): Visual status indicator for system state, faults, connectivity, etc.</p> </li> <li> <p>5V 1.5A Voltage Regulator (LM7805CT): Ensures reliable power supply, Converts 9 V to 5V.</p> </li> </ul>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#block-diagram","title":"Block Diagram","text":"","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#resources","title":"Resources","text":"<p>The block diagram as a draw.io XML file is available for download here.</p>","tags":["tag1","tag2"]},{"location":"02-Component-Selection/Component-Selection/","title":"Component Selection","text":"<p>LDR</p> <ol> <li> <p>Advanced Photonix PDV-P9203</p> <p></p> <ul> <li>$1.5/each</li> <li>link to product</li> </ul> Pros Cons Has a specified resistance of 10 k\u03a9 to 30 k\u03a9 at ~10 lux. Response (rise time) is relatively slow: typ ~70 ms. Good light sensitivity range (visible light around 570 nm) </li> <li> <p>Adafruit CDS Photoresistor</p> <p></p> <ul> <li>$0.9/each</li> <li>Link to product</li> </ul> Pros Cons Pros  Cons Very low resistance in light. gives strong variation. More resources compared to Advanced Photonix PDV-P9203 Inexpencive </li> </ol> <p>Choice: Option 2: Adafruit CDS Photoresistor</p> <p>Rationale: Clear Light vs Dark discrimination, Low cost, Simple integration.</p> <p>OP-AMP</p> <ol> <li> <p>Microchip MCP6004-I/P</p> <p></p> <ul> <li>$1.5/each</li> <li>link to product</li> </ul> Pros Cons easier to use with 3.3 V MCUs and single-supply designs. Lower drive current than LM324 Fits the scope of this class. </li> <li> <p>Texas Instruments LM324N</p> <p></p> <ul> <li>$0.47/each</li> <li>Link to product</li> </ul> Pros Cons Very cheap and widely available Very low resistance in light. gives strong variation. Not rail-to-rail; output won\u2019t swing to VCC, which complicates 3.3 V MCU interfacing. Inexpencive </li> </ol> <p>Choice: Option 1: Microchip MCP6004-I/P.</p> <p>Rationale: The MCP6004 is ideal because it\u2019s rail-to-rail, low-power, and perfectly suited for accurate 3.3 V sensor interfacing in your lawn-watering system.</p> <p>Voltage Regulator</p> <ol> <li> <p>LM7805T Linear Voltage Regulator</p> <p></p> <ul> <li>$0.33/each</li> <li>link to product</li> </ul> Pros Cons Inexpensive Inefficient, heat dissipation at higher voltage difference Output Current 1.5A </li> <li> <p>MC7805CT-BP Linear Voltage Regulator</p> <p></p> <ul> <li>$0.75/each</li> <li>Link to product</li> </ul> Pros Cons Inexpensive Higher Input Voltage (25 V) Output Current 1.5A Not provided in the Lab Kit </li> </ol> <p>Choice: Option 1: MC7805CT-BP Linear Voltage Regulator</p> <p>Rationale: The LM7805T regulator is included in the lab kit, which helps reduce the budget, shipment time and is good enough for my use case.</p>"},{"location":"02-Component-Selection/Component-Selection/#summary-table","title":"Summary Table","text":"<p>Table 1: Summary Table of Final Major Components Selected</p> Component Type Selected Option Price Key Reason for Selection Op-Amp MCP6004-I/P Rail-to-Rail Op-Amp $1.50 Rail-to-rail operation, low-power, ideal for 3.3V sensor interfacing Photoresistor Adafruit CDS Photoresistor $0.90 Clear light vs dark discrimination, low cost, simple integration Voltage Regulator MC7805CT-BP Linear Voltage Regulator $0.75 Lab kit part, easy to order, adequate performance"},{"location":"02-Component-Selection/Component-Selection/#mcc-pin-configuration","title":"MCC Pin Configuration","text":"<p>The image above shows my MCC pin configuration. I am using ADC to read values from potentiometer and LDR, and I am using the capture function of CCP to capture PWM signal from the moisture sensor subsystem. UART is used for debugging and displaying results on data visualizer in MCC, and everything else is GPIO.</p>"},{"location":"03-BOM/BOM/","title":"Bill of Materials","text":"","tags":["tag1","tag2"]},{"location":"03-BOM/BOM/#overview","title":"Overview","text":"<p>Below is the bill of materials for my PCB design, which includes the power regulation stage, user-interface components, connectors, and the PIC18F57Q43 Curiosity Nano module used as the system\u2019s microcontroller. Many of the passive components can be sourced directly from Peralta 109, while specialty items such as the voltage regulator, potentiometer, and headers are ordered through Digi-Key. Pin headers and the onboard pushbutton are included to support debugging and flexible testing during development. Most parts carry minimal or no cost, with the Curiosity Nano and a few ordered components making up the majority of expenses. Even when accounting for extra units of key parts for testing, the overall cost remains well within the project\u2019s budget requirements.</p>","tags":["tag1","tag2"]},{"location":"03-BOM/BOM/#bill-of-materials-example-as-image","title":"Bill of Materials Example (as Image)","text":"","tags":["tag1","tag2"]},{"location":"03-BOM/BOM/#resouces","title":"Resouces","text":"<p>The BOM as a xlsx download is available here</p>","tags":["tag1","tag2"]},{"location":"04-Schematic/schematic/","title":"Schematic","text":"<p> Figure 01: Figure showing the hub schematic.</p>"},{"location":"04-Schematic/schematic/#resources","title":"Resources","text":"<p>The schematic as a PDF download is available here, and the Zip folder of the project here.</p>"},{"location":"05-PCB/pcb/","title":"PCB","text":""},{"location":"05-PCB/pcb/#overview","title":"Overview","text":"<p>This PCB serves as the central hub for a PIC18-based water sprinkler system. It includes an LM7805 regulator supplying 5 V / 1.5 A from a 9 V input with fuse protection. The PIC18F57Q43 Curiosity Nano interfaces with analog inputs (potentiometer and sensors), digital I/O for push buttons, and PWM outputs for motor and speaker control. Three 8-pin connectors provide power and communication to subsystem boards. Debugging features include an onboard LED, push button, test points, and accessible headers, with ground planes for signal stability and integrated overcurrent protection.</p> <p> Figure 01: Figure showing top PCB layer.</p> <p> Figure 02: Figure showing bottom PCB layer.</p> <p> Figure 03: Figure showing manufactured and soldered PCB top layer.</p> <p> Figure 04: Figure showing manufactured and soldered PCB bottom layer.</p>"},{"location":"05-PCB/pcb/#resouces","title":"Resouces","text":"<p>The PCB design as a PDF download is available here - top,bottom,The DRC Check PDF here, The JLC DFM Check here and the Gerber Zip folder of the project here.</p>"},{"location":"06-Power-Budget/Power-Budget/","title":"Power Budget","text":""},{"location":"06-Power-Budget/Power-Budget/#overview","title":"Overview","text":"<p>The power budget was created to estimate the total power consumption of the system, ensuring that the 5V regulator and power supply can safely support all components under normal and peak conditions. Each device\u2019s voltage, current, and power were calculated and summed, with a 25% safety margin added to account for variations. This confirmed that the regulator\u2019s 1500 mA capacity provides ample headroom. Heat dissipation was also evaluated, showing that a linear regulator (9\u21925V) would lose about 0.86 W, while a switching regulator would lose only 0.12 W. Overall, the power budget ensures reliability, efficiency, and proper power management in the circuit design.</p> <p></p>"},{"location":"06-Power-Budget/Power-Budget/#conclusions","title":"Conclusions","text":"<p>The power budget shows that the system draws about 214 mA and 1.07 W with margin, well below the regulator\u2019s 1500 mA limit. Establishing a detailed power budget was critical to the design process, as it ensured that component selections were both electrically compatible and thermally stable under expected operating conditions. Both linear and switching regulators can handle the load, though switching offers better efficiency. Overall, the design is safe, efficient, and leaves plenty of headroom for expansion.</p>"},{"location":"06-Power-Budget/Power-Budget/#resouces","title":"Resouces","text":"<p>The power budget as a PDF download is available here, and a Microsoft Excel Sheet here.</p>"},{"location":"07-Microcontroller-Code/Microcontroller-Code/","title":"Microcontroller Code","text":""},{"location":"07-Microcontroller-Code/Microcontroller-Code/#overview","title":"Overview","text":"<p>This section documents the microcontroller firmware for the central hub subsystem. The code is written in C and compiled using MPLAB X IDE for the Microchip PIC18F57Q43 Curiosity Nano microcontroller. The firmware implements the hub-and-spoke architecture, managing user inputs (potentiometer, LDR, button), processing sensor data, and controlling outputs (LED, speaker, motor) based on the system logic.</p> <p>The code utilizes various peripherals including: - ADCC: For analog inputs from potentiometer (RA3) and LDR (RA2 via MCP6004 amplifier) - GPIO: For digital I/O including button input (RB4), LED output (RD4), and motor/speaker control - PWM/CCP: For motor and speaker control - EUSART/UART: For inter-board communication</p>"},{"location":"07-Microcontroller-Code/Microcontroller-Code/#main-code","title":"Main Code","text":"<pre><code>//Ragul Raj\n// Water Only when PWM Duty Cycle is above 175\n\n#include \"mcc_generated_files/system/system.h\"\n#include \"mcc_generated_files/capture/ccp1.h\"\n#include \"mcc_generated_files/adc/adc.h\"\n#include &lt;xc.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n#ifndef _XTAL_FREQ\n#define _XTAL_FREQ 16000000UL   // match your MCC System Clock\n#endif\n\n// Redirect printf() to UART1\nvoid putch(char data)\n{\n    while (!UART1_IsTxReady());   // wait until UART ready\n    UART1_Write((uint8_t)data);   // send one byte\n}\n\n/* Global variables */\nvolatile uint16_t rise_time = 0;\nvolatile uint16_t last_rise_time = 0;\nvolatile uint16_t pulse_width_ticks = 0;  // Raw Timer1 tick value (HIGH time)\nvolatile uint16_t period_ticks = 0;       // Raw Timer1 tick value (period)\nvolatile bool new_pulse = false;\nvolatile bool capture_active = false;  // Flag to control capture\n\n/* CCP1 Callback - captures rising and falling edges to measure pulse width and period */\nvoid CCP1_CallBack(uint16_t capturedValue)\n{\n    if (!capture_active) return;  // Only capture when function is active\n\n    uint8_t mode = CCP1CON &amp; 0x0F;\n\n    if (mode == 0b0101)                     // Rising edge just happened\n    {\n        // Calculate period (time between this rising edge and previous rising edge)\n        if (last_rise_time != 0)\n        {\n            uint16_t period_diff;\n            if (capturedValue &gt;= last_rise_time)\n                period_diff = capturedValue - last_rise_time;\n            else\n                period_diff = (0xFFFFU - last_rise_time) + capturedValue + 1;\n\n            period_ticks = period_diff;\n        }\n\n        last_rise_time = capturedValue;\n        rise_time = capturedValue;\n        CCP1CON = (CCP1CON &amp; 0xF0) | 0b0100; // Next: capture falling edge\n    }\n    else if (mode == 0b0100)                // Falling edge just happened\n    {\n        uint16_t diff;\n        if (capturedValue &gt;= rise_time)\n            diff = capturedValue - rise_time;\n        else\n            diff = (0xFFFFU - rise_time) + capturedValue + 1;\n\n        // Store raw Timer1 tick value (pulse width)\n        pulse_width_ticks = diff;\n        new_pulse = true;\n\n        CCP1CON = (CCP1CON &amp; 0xF0) | 0b0101; // Re-arm for next rising edge\n    }\n}\n\n/* -----------------------\n   Initialize PWM capture hardware\n   - Sets up Timer1 and CCP1 for PWM capture\n   - Should be called once at startup\n   ----------------------- */\nvoid PWM_Capture_Init(void)\n{\n    // Force Timer1 to 16 MHz (Fosc/4) - required for correct timing\n    T1CLKbits.CS = 0b00010;   // Timer1 clock = Fosc/4\n    T1CONbits.CKPS = 0b00;    // 1:1 prescaler\n    T1CONbits.RD16 = 1;\n    T1CONbits.ON = 1;\n\n    // Force CCP1 into \"every rising edge\" mode (overrides MCC setting)\n    CCP1CON = 0x85;           // 0b10000101 = enabled + every rising edge\n\n    // Register our callback\n    CCP1_SetCallBack(CCP1_CallBack);\n\n    // CORRECT interrupt enables for current MCC (2024-2025)\n    INTCON0bits.GIEH = 1;     // Global Interrupt High Enable\n    INTCON0bits.GIEL = 1;     // Global Interrupt Low Enable\n\n    // Reset state\n    rise_time = 0;\n    last_rise_time = 0;\n    pulse_width_ticks = 0;\n    period_ticks = 0;\n    new_pulse = false;\n    capture_active = false;\n}\n\n/* -----------------------\n   Read PWM pulse width\n   - Waits for a PWM pulse and returns raw Timer1 tick value\n   - Returns 0xFFFF if timeout occurs\n   - timeout_ms: Maximum time to wait in milliseconds (0 = wait forever)\n   ----------------------- */\nuint16_t PWM_Read(uint16_t timeout_ms)\n{\n    uint16_t result = 0xFFFF;  // Error/Timeout value\n    uint16_t timeout_count = 0;\n\n    // Enable capture\n    capture_active = true;\n    new_pulse = false;\n\n    // Wait for a pulse\n    if (timeout_ms == 0)\n    {\n        // Wait forever\n        while (!new_pulse)\n        {\n            __delay_ms(1);\n        }\n    }\n    else\n    {\n        // Wait with timeout\n        while (!new_pulse &amp;&amp; timeout_count &lt; timeout_ms)\n        {\n            __delay_ms(1);\n            timeout_count++;\n        }\n    }\n\n    // If we got a pulse, return the value\n    if (new_pulse)\n    {\n        result = pulse_width_ticks;\n        new_pulse = false;\n    }\n\n    // Disable capture until next call\n    capture_active = false;\n\n    return result;\n}\n\n/* -----------------------\n   Read multiple PWM pulses and return average duty cycle (0-255)\n   - Collects num_samples pulses and returns average duty cycle\n   - timeout_ms: Maximum time to wait for all samples\n   - Returns 0xFFFF if timeout or no samples collected\n   ----------------------- */\nuint16_t PWM_Read_DutyCycle(uint16_t num_samples, uint16_t timeout_ms)\n{\n    uint32_t sum_pulse_width = 0;\n    uint32_t sum_period = 0;\n    uint16_t count = 0;\n    uint16_t timeout_count = 0;\n\n    // Reset last_rise_time to start fresh period measurement\n    last_rise_time = 0;\n    period_ticks = 0;\n\n    // Enable capture\n    capture_active = true;\n\n    // Collect samples\n    while (count &lt; num_samples &amp;&amp; timeout_count &lt; timeout_ms)\n    {\n        if (new_pulse)\n        {\n            // Only use sample if we have both pulse width and period\n            if (period_ticks &gt; 0 &amp;&amp; pulse_width_ticks &gt; 0)\n            {\n                sum_pulse_width += pulse_width_ticks;\n                sum_period += period_ticks;\n                count++;\n            }\n            new_pulse = false;\n        }\n        __delay_ms(1);\n        timeout_count++;\n    }\n\n    // Disable capture until next call\n    capture_active = false;\n\n    if (count == 0 || sum_period == 0)\n        return 0xFFFF;  // No samples collected or invalid period\n\n    // Calculate average duty cycle: (pulse_width / period) * 255\n    uint32_t avg_pulse_width = sum_pulse_width / count;\n    uint32_t avg_period = sum_period / count;\n\n    // Duty cycle = (pulse_width / period) * 255\n    // Use 32-bit math to avoid overflow\n    uint32_t duty_cycle = ((uint32_t)avg_pulse_width * 255UL) / avg_period;\n\n    // Clamp to 0-255 range\n    if (duty_cycle &gt; 255)\n        duty_cycle = 255;\n\n    return (uint16_t)duty_cycle;\n}\n\nvoid main(void)\n{\n    SYSTEM_Initialize();      // MCC initializes everything\n\n    Sensor_State_SetDigitalOutput();\n    Sensor_State_SetLow();   // Start with sensor disabled\n    Motor_Out_SetDigitalOutput();\n    Motor_Out_SetLow();      // Start with motor off\n    LED_SetDigitalOutput();\n    LED_SetLow();    // Start with LED off\n    Speaker_Out_SetDigitalOutput();\n    Speaker_Out_SetLow();    // Start with speaker off\n    BTN_SetDigitalInput();\n    // BTN has pull-down resistor, so no pull-up needed\n\n    // Initialize PWM capture hardware\n    PWM_Capture_Init();\n\n    // Initialize ADC (ensure it's ready)\n    ADC_Initialize();\n\n    printf(\"\\033[2J\\033[HPIC18F57Q43 PWM Capture Ready (RC0)\\r\\n\");\n    printf(\"Timer1: 16MHz (FOSC/4, 1:1 prescaler)\\r\\n\");\n    printf(\"Press BTN to check LDR and read PWM\\r\\n\\r\\n\");\n\n    while(1)\n    {\n        if (BTN_GetValue() == 1)   // Button pressed (goes HIGH when pressed)\n        {\n            __delay_ms(30);        // Debounce\n            if (BTN_GetValue() == 1)\n            {\n                // Read LDR ADC value\n                uint16_t ldr_value = ADC_ChannelSelectAndConvert(LDR);\n\n                printf(\"LDR ADC: %u\\r\\n\", ldr_value);\n\n                // Check if LDR value is above threshold\n                if (ldr_value &gt; 2000)\n                {\n                    // Dark enough - enable sensor and read PWM\n                    Sensor_State_SetHigh();\n                    __delay_ms(100);   // Give sensor time to stabilize\n\n                    // Read duty cycle from 50 samples\n                    uint16_t duty_cycle = PWM_Read_DutyCycle(50, 5000); // 50 samples, 5 second timeout\n\n                    // Disable sensor\n                    Sensor_State_SetLow();\n\n                    // Check duty cycle and act accordingly\n                    if (duty_cycle != 0xFFFF)\n                    {\n                        printf(\"Duty cycle: %u (0-255)\\r\\n\", duty_cycle);\n\n                        // Check soil moisture level\n                        if (duty_cycle &lt; 175)\n                        {\n                            // Soil is sufficiently moist\n                            printf(\"Soil is Sufficiently Moistured\\r\\n\");\n                        }\n                        else\n                        {\n                            // Soil needs water - activate motor and speaker\n                            printf(\"Watering...\\r\\n\");\n\n                            // Set motor and speaker outputs HIGH\n                            Motor_Out_SetHigh();\n                            Speaker_Out_SetHigh();\n                            LED_SetHigh();\n\n                            // Wait 1 second (1000ms)\n                            __delay_ms(1000);\n\n                            // Set motor and speaker outputs LOW\n                            Motor_Out_SetLow();\n                            Speaker_Out_SetLow();\n                            LED_SetLow();\n                            printf(\"Watering complete\\r\\n\");\n                        }\n                    }\n                    else\n                    {\n                        printf(\"Timeout - no PWM detected\\r\\n\");\n                    }\n                }\n                else\n                {\n                    // Too bright - don't water\n                    printf(\"It is too bright to water\\r\\n\");\n                }\n\n                while (BTN_GetValue() == 1) { __delay_ms(20); }  // wait for release\n                __delay_ms(50);   // release debounce\n            }\n        }\n\n        __delay_ms(10);  // Small delay in main loop\n    }\n}\n</code></pre>"},{"location":"07-Microcontroller-Code/Microcontroller-Code/#resources","title":"Resources","text":"<p>The complete MPLAB X project files are available for download:</p> <ul> <li>MPLAB X Project Zip: Download here</li> </ul>"},{"location":"08-Hardware-V2.0/Hardware-V2.0/","title":"Hardware V2.0","text":""},{"location":"08-Hardware-V2.0/Hardware-V2.0/#overview","title":"Overview","text":"<p>This section discusses hardware improvements and changes that would be implemented in a future revision (V2.0) of the subsystem. Based on testing, manufacturing experience, and system integration, several specific areas have been identified for optimization to improve debugging capabilities, component placement, and overall board layout.</p>"},{"location":"08-Hardware-V2.0/Hardware-V2.0/#planned-hardware-improvements","title":"Planned Hardware Improvements","text":""},{"location":"08-Hardware-V2.0/Hardware-V2.0/#additional-test-points","title":"Additional Test Points","text":"<p>One of the primary improvements for V2.0 would be the addition of more test points throughout the PCB, with particular focus on critical circuit sections:</p> <ul> <li> <p>Op-amp circuit test points: Add test points at key nodes in the MCP6004 operational amplifier circuit to facilitate easier debugging and signal verification. This would include test points for the LDR input signal, op-amp output, and power supply rails.</p> </li> <li> <p>5V regulator circuit test points: Add test points around the LM7805CT voltage regulator circuit to monitor input voltage, output voltage, and ground connections. This would help diagnose power supply issues and verify proper regulation.</p> </li> </ul> <p>These additional test points would significantly improve the ability to troubleshoot and validate circuit operation during testing and debugging phases.</p>"},{"location":"08-Hardware-V2.0/Hardware-V2.0/#light-sensor-relocation","title":"Light Sensor Relocation","text":"<p>The light-dependent resistor (LDR) would be relocated to a less crowded area of the PCB. The current placement creates challenges with component density and routing. Moving the LDR to a more open area would:</p> <ul> <li>Improve accessibility for testing and calibration</li> <li>Reduce interference from nearby components</li> <li>Simplify routing and improve signal integrity</li> <li>Make assembly and rework easier</li> </ul>"},{"location":"08-Hardware-V2.0/Hardware-V2.0/#pcb-size-optimization","title":"PCB Size Optimization","text":"<p>The current PCB design contains significant empty space that could be utilized more efficiently. For V2.0, the board dimensions would be reduced by:</p> <ul> <li>Optimizing component placement to minimize board area</li> <li>Consolidating routing to reduce unused space</li> <li>Improving overall board density while maintaining manufacturability</li> </ul> <p>A smaller PCB would reduce material costs, improve mechanical integration, and create a more compact subsystem.</p>"},{"location":"08-Hardware-V2.0/Hardware-V2.0/#header-pin-repositioning","title":"Header Pin Repositioning","text":"<p>The header pins that connect to other subsystems would be repositioned and spaced further apart. The current configuration makes wire fitting too congested, which leads to:</p> <ul> <li>Difficulty in connecting wires during assembly</li> <li>Risk of short circuits from closely spaced connections</li> <li>Challenges in maintenance and troubleshooting</li> </ul> <p>By increasing the spacing between header pins, wire connections would become more manageable, reducing assembly time and improving reliability of inter-subsystem connections.</p>"},{"location":"08-Hardware-V2.0/Hardware-V2.0/#conclusion","title":"Conclusion","text":"<p>The planned improvements for Hardware V2.0 focus on enhancing debugging capabilities through additional test points, improving component placement and accessibility, optimizing board size, and making inter-subsystem connections more manageable. These changes would result in a more maintainable, easier-to-assemble, and more compact design while maintaining all existing functionality.</p>"},{"location":"09-Resources/Resources/","title":"Resources","text":""},{"location":"09-Resources/Resources/#overview","title":"Overview","text":"<p>This page provides access to downloadable project files including the complete KiCad PCB design project and the MPLAB X IDE microcontroller firmware project. These resources allow for complete reproduction, modification, and further development of the subsystem.</p>"},{"location":"09-Resources/Resources/#kicad-project","title":"KiCad Project","text":"<p>The complete KiCad project files for the PCB design are available for download. This includes:</p> <ul> <li>Schematic design files</li> <li>PCB layout files</li> <li>Component libraries</li> <li>Design rules and constraints</li> <li>All project configuration files</li> </ul> <p>KiCad Project Files: Download here</p>"},{"location":"09-Resources/Resources/#mplab-x-project","title":"MPLAB X Project","text":"<p>The complete MPLAB X IDE project for the microcontroller firmware is available for download. This includes:</p> <ul> <li>Source code files (.c and .h)</li> <li>Project configuration files</li> <li>MCC (MPLAB Code Configurator) generated files</li> <li>Build configuration</li> <li>Debug settings</li> </ul> <p>MPLAB X Project Files: Download here</p>"},{"location":"Appendix/","title":"Appendix - Main Page","text":"<p>The Appendix is where supporting information goes that is not in the main body.</p>"},{"location":"Appendix/another-subfile/","title":"Appendix - Another Subfile","text":"<p>Things to discuss</p>"},{"location":"Appendix/basic-markdown-examples/","title":"Appendix - Basic Markdown Examples","text":""},{"location":"Appendix/basic-markdown-examples/#introduction","title":"Introduction","text":"<p>Bold Text Italic Text Bold and Italic Text</p>"},{"location":"Appendix/basic-markdown-examples/#research-question","title":"Research Question","text":"<ul> <li>Bullet Point 1</li> <li>Bullet Point 2</li> <li>Bullet Point 3</li> </ul>"},{"location":"Appendix/basic-markdown-examples/#images","title":"Images","text":"<p> Figure 2: Early PCB working design</p> <p> Figure 3: Innovation Showcase Spring '25, where the products were a STEM-themed display that demonstrates a single scientific/engineering concept with the intended user of K-12 students interested in learning about science, technology, engineering, or math.</p>"},{"location":"Appendix/basic-markdown-examples/#results","title":"Results","text":"<ol> <li>Numbered Point 1</li> <li>Numbered Point 2</li> <li>Numbered Point 3</li> </ol>"},{"location":"Appendix/basic-markdown-examples/#conclusions-and-future-work","title":"Conclusions and Future Work","text":""},{"location":"Appendix/basic-markdown-examples/#external-links","title":"External Links","text":"<p>example link to idealab</p>"},{"location":"Appendix/basic-markdown-examples/#results_1","title":"Results","text":"<ol> <li>Numbered Point 1</li> <li>Numbered Point 2</li> <li>Numbered Point 3</li> </ol>"},{"location":"Appendix/basic-markdown-examples/#conclusions-and-future-work_1","title":"Conclusions and Future Work","text":""},{"location":"Appendix/basic-markdown-examples/#external-links_1","title":"External Links","text":"<p>example link to idealab</p>"},{"location":"Appendix/basic-markdown-examples/#references","title":"References","text":""},{"location":"Appendix/charts/","title":"Appendix - Charts Example","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre>"},{"location":"Appendix/esp-32-table/","title":"Appendix - Example Controller Table for the ESP32","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Found on Espressif.com ESP32-S3-WROOM-1-N4 Datasheet URL ? Do not paste links directly into the table.  Use a link ESP32 S3 Datasheet URL ? Has more detail on functions ESP32 S3 Technical Reference Manual URL ? Has details on I/O multiplexing, USB, and others Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find on Digikey, Jameco, MPJA, or octopart Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? as found in datasheet Module # Available Needed Associated Pins (or * for any) UART ? ? ? external SPI* ? ? ? I2C ? ? ? GPIO ? ? ? ADC ? ? ? LED PWM ? ? ? Motor PWM ? ? ? USB Programmer ? 1 ? ... <p>* The ESP32-S2 has multiple SPI interfaces, but some are for internal use</p>"}]}